
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>Theory of operation Â· HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 4.0.4">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="PdM_Externals.html" />
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a target="frame" href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="FAQ.html">
            
                <a target="frame" href="FAQ.html">
            
                    
                    F.A.Q.
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    Setup
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" >
            
                <span>
            
                    
                    DAW Integration
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1.1" data-path="Setup_Ableton.html">
            
                <a target="frame" href="Setup_Ableton.html">
            
                    
                    1. Ableton
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.2" data-path="Setup_Bitwig.html">
            
                <a target="frame" href="Setup_Bitwig.html">
            
                    
                    2. Bitwig Studio
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.3" data-path="Setup_Reaper.html">
            
                <a target="frame" href="Setup_Reaper.html">
            
                    
                    3. Reaper
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.4" data-path="Setup_Ardour.html">
            
                <a target="frame" href="Setup_Ardour.html">
            
                    
                    4. Ardour
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.5" data-path="Setup_FL.html">
            
                <a target="frame" href="Setup_FL.html">
            
                    
                    5. FL Studio
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.6" data-path="Setup_One.html">
            
                <a target="frame" href="Setup_One.html">
            
                    
                    6. Studio One
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.7" data-path="Setup_Logic.html">
            
                <a target="frame" href="Setup_Logic.html">
            
                    
                    7. Logic
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="2.1" >
            
                <span>
            
                    
                    Pd Manual
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="2.1.1" data-path="PdM_TheoryOfOperation.html">
            
                <a target="frame" href="PdM_TheoryOfOperation.html">
            
                    
                    Theory of operation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.2" data-path="PdM_Externals.html">
            
                <a target="frame" href="PdM_Externals.html">
            
                    
                    Externals
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="Resources.html">
            
                <a target="frame" href="Resources.html">
            
                    
                    Resources
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a target="frame" href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a target="frame" href="." >Theory of operation</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <p>  Pd Manual 2   </p>
<h2 id="pd-manual-chapter-2-theory-of-operation">Pd Manual chapter 2: theory of operation</h2>
<p>The purpose of this chapter is to describe Pd&apos;s design and how it is supposed to work. Practical details about how to obtain, install, and run Pd are described in the <a target="frame" href="x3.html">next chapter</a>. Links to more extensive guides (and to more theoretical information about computer music) can be found in the <a target="frame" href="x1.html">previous chapter</a>.</p>
<h3 id="21-overview">2.1 overview</h3>
<p>Pd is a real-time graphical programming environment for audio and graphical processing. It resembles the Max/MSP system but is much simpler and more portable; also Pd has two features not (yet) showing up in Max/MSP: first, via Mark Dank&apos;s GEM package, Pd can be used for simultaneous computer animation and computer audio. Second, an experimental facility is provided for defining and accessing data structures.</p>
<h3 id="211-the-main-window-canvases-and-printout">2.1.1. the main window, canvases, and printout</h3>
<p>When Pd is running, you&apos;ll see a main &quot;Pd&quot; window, and possibly one or more &quot;canvases&quot; or &quot;patches&quot;. The main Pd window looks like this:</p>
<p><img src="images/fig1.1.png" alt="pd window"></p>
<p>The bottom part of the Pd window is an area for printout from objects in patches, and/or for messages from Pd itself. The menus and console font size can be changed using the <strong>Edit/Font</strong> menu dialog when the Pd window is focused. Make your adjustments if you are having troubles reading on HiDPI screens.</p>
<p>Pd documents are called &quot;patches&quot; or &quot;canvases.&quot; Each open document has one main window and any number of sub-windows. The sub-windows can be opened and closed but are always running whether you can see them or not. Here is a simple Pd patch:</p>
<p><img src="images/fig1.2.jpg" alt="hello world patch"></p>
<p>There are four <em>text boxes</em> in this patch: a number box (showing zero), an object box showing &quot;print,&quot; and two comments. The number box and the object box are connected, the number box&apos;s output to the print box&apos;s input. Boxes may have zero or more inputs and/or outputs, with the inputs on top and the outputs on bottom.</p>
<p>Pd&apos;s printout appears on the main &quot;Pd&quot; window, unless you redirect it elsewhere.</p>
<h3 id="212-object-boxes">2.1.2. object boxes</h3>
<p>Pd patches can have four types of boxes: <em>object, message, GUI,</em> and <em>comment</em> .</p>
<p>You make <em>objects</em> by typing text into object boxes. The text is divided into <em>atoms</em> separated by white space. The first atom specifies what type of object Pd will make, and the other atoms, called <em>creation arguments</em> , tell Pd how to initialize the object. If you type for example,</p>
<p><img src="images/fig1.3.jpg" alt="object"></p>
<p>the &quot;+&quot; specifies the <em>class</em> of the object. In this case the object will be the kind that carries out addition, and the &quot;13&quot; initializes the amount to add.</p>
<p>Atoms are either numbers or <em>symbols</em> like &quot;+&quot;. Anything that is not a valid number is considered a symbol. Valid numbers may or may not have a decimal point (for instance, 12, 15.6, -.456), or may be written in exponential notation (such as &quot;4.5e6&quot;, which means &quot;4.5 multiplied by 10 six times, i.e., 4500000). Negative exponentials divide by 10 (so that 1.23e-5 comes to 0.0000123).</p>
<p>Non-valid numbers which are read as symbols include things like &quot;+5&quot; and &quot;0..6&quot; as well as words and names such as &quot;Zack&quot; or &quot;cat&quot;. The symbols &quot;gore&quot;, &quot;Gore&quot;, and &quot;GORE&quot; are all distinct.</p>
<p>The text you type into an object box determines how many and what kinds of inlets and outlets the object will have. Some classes (like &quot;+&quot; always have a fixed arrangement of inlets and outlets, and in the case of other classes, the inlets and outlets will depend on the creation arguments.</p>
<p>Here for example is a simple MIDI synthesizer:</p>
<p><img src="images/fig1.4.png" alt="simple MIDI synthesizer"></p>
<p>This patch mixes <em>control</em> objects (notein, stripnote, and ftom) with <em>tilde</em> objects osc~, *~, and dac~. The control objects carry out their function sporadically, as a result of one or more type of <em>event</em> . In this case, incoming MIDI note messages set off the control computation. The result of the computation is, when the note happens to be a &quot;note on&quot; (and not a &quot;note off&quot;, to compute the frequency in cycles per second and pass it on to the oscillator (&quot;osc~&quot;).</p>
<p>The second half of the patch, the osc~, *~, and dac~ objects, compute audio samples, in the same way as an analog synthesizer works. The osc~ object is acting as the interface between the two regimes, in that it takes control messages to set its frequency but talks to &quot;*~&quot; using an audio signal. Audio signals aren&apos;t sporadic; they are continuous streams of numbers. As a result tilde objects act under very different rules from control objects. The audio portion of the patch is always running, whether MIDI messages arrive or not. On the other hand, the function of control computations is to insert calculations between the audio computation which may change audio computation parameters such as the frequency of an oscillator.</p>
<p>The connections in the patch (the lines between the boxes) are also of two types: control and signal. The type of connection depends on the outlet it comes from. Signal connections are represented by thicker lines than control connections; in the patch above, the two bottom connections are signal and the others are control. In general, a control connection may be made to a signal inlet; if numbers are sent over it they are automatically converted to signals. Signal connections may not be made to control inlets; some sort of explicit conversion must be specified.</p>
<h3 id="213-message-and-gui-boxes">2.1.3. message and GUI boxes</h3>
<p>The border of a box tells you how its text is interpreted and how the box functions. Object boxes (as in the previous example) use the text to create objects when you load a patch or type text onto a new one. If you retype the text in an object box, the old one is discarded and a new one is created, using the new creation arguments. The contents of an object box describe a message which is sent to Pd to create the object.</p>
<p><em>Message</em> boxes interpret the text as a message to send whenever the box is activated (by an incoming message or with the mouse.) The message may be sent many times while the patch is running (as opposed to object boxes whose message is used once to create the object). Instead of going straight to Pd, the message box&apos;s message (or messages) go either to the box&apos;s outlet or to other specified receiving objects. In the example below, the message box, when clicked, sends the message &quot;21&quot; to an object box which adds 13 to it.</p>
<p><img src="images/fig1.5.jpg" alt="[message( --&gt; [object] -&gt; [number]"></p>
<p>The third box shown is a <em>GUI</em> (&quot;graphical user interface&quot;) box. GUI boxes come in many forms including number boxes (as in this example), toggles, sliders, and so on. Whereas the appearance of an object or message box is static when a patch is running, a number box&apos;s contents (the text) changes to reflect the current value held by the box. You can also use a number box as a control by clicking and dragging up and down, or by typing values in it. (There are also shift- and alt-click actions; see <a target="frame" href="x2.html#s2.7">getting help</a> to find out how to look this up).</p>
<p>In addition to numbers, Pd defines GUI boxes to display and edit symbols or arbitrary lists of atoms.</p>
<h3 id="214-patches-and-files">2.1.4. patches and files</h3>
<p>When you save a patch to a file, Pd doesn&apos;t save the entire state of all the objects in the patch, but only what you see: the objects&apos; creation arguments and their interconnections. Certain data-storage objects have functions for reading and writing other files to save and restore their internal state.</p>
<p>Pd finds files using a <em>path</em> which can be specified as part of Pd&apos;s startup arguments. The path specifies one or more directories, separated by colons (semicolons if you&apos;re using windows.) Most objects which can read files search for them along the search path, but when Pd writes files they go to the directory where the patch was found.</p>
<h3 id="22-editing-pd-patches">2.2. editing Pd patches</h3>
<h3 id="221-edit-and-run-mode">2.2.1. edit and run mode</h3>
<p>A patch can be in edit or run mode; this really only affects how mouse clicks affect the patch. In edit mode, clicking and dragging selects and moves boxes or makes and cuts connections; in run mode clicking on boxes sends them messages which they react to in different ways. In run mode, number and message boxes can be used as controls. Normally, when you are in a performance you will stay in run mode; to change the patch you go to edit mode.</p>
<h3 id="222-creating-boxes">2.2.2. creating boxes</h3>
<p>You can create boxes (objects, messages, GUIs, and comments) using the &quot;put&quot; menu. Note the handy accelerators. Object and message boxes are empty at first; drag them where you want them and type in the text. The GUI objects (which come in several flavors) require no typing; just create and place them.</p>
<p>You will often find it more convenient to select a box and &quot;duplicate&quot; it (in the Edit menu) than to use the &quot;Put&quot; menu. If you select and duplicate several items, any connections between them will be duplicated as well.</p>
<h3 id="223-the-selection">2.2.3. the selection</h3>
<p>Boxes in a Pd window may be selected by clicking on them. To select more than one object you may use shift-click or click on a blank portion of the window and drag the cursor to select all objects within a rectangle.</p>
<p>Clicking on an unselected object, message, or comment box makes the text active, i.e., ready to be text edited. (If you select using the rectangle method, the text isn&apos;t activated.) Once you&apos;ve activated a text box, you may type into it (replacing the selected text) or use the mouse to change the selection.</p>
<p>You may also select a single connection (patch cord) by clicking on it. You can&apos;t have connections and boxes selected simultaneously.</p>
<h3 id="224-deleting-cutting-and-pasting">2.2.4. deleting, cutting, and pasting</h3>
<p>If you select a box, a connection, or several boxes, and if you haven&apos;t made any text active, you can &quot;delete&quot; the selection by hitting the backspace or delete key. You can also &quot;cut&quot; &quot;copy&quot; and &quot;paste&quot; using menu items. Notice that pasting puts the new object(s) right down on top of the old ones.</p>
<p>The &quot;duplicate&quot; menu item performs a copy and paste with a small offset so you can see the new boxes. You can drag them together to a new place on the screen.</p>
<p>You can cut and paste between windows within Pd but cut/paste isn&apos;t integrated with the OS in any way. Cut/copy/paste for activated text in boxes isn&apos;t implemented yet, although in Linux at least you can &quot;X-paste&quot; into and out of &quot;text&quot; dialogs (created with the &quot;edit text&quot; menu item.)</p>
<h3 id="225-changing-the-text">2.2.5. changing the text</h3>
<p>To change a text item, you can select it and then edit the text. If you only click once, the entire text is selected and your typing will replace everything. Click again and drag to select a portion of the text to retype.</p>
<p>If there&apos;s more than a small amount of text (in a comment, for example) you might want to select the text and choose &quot;text editor&quot; from the Edit menu, which opens a text editing window with a copy of the text in it. Hitting &quot;send&quot; in that window is exactly equivalent to retyping the text into Pd; you can send it to more than one box in sequence if you want.</p>
<p>If you click a box and move the mouse without releasing the button this displaces the entire box. If you wish to displace a box which is already selected, first de-select the box by clicking outside it; otherwise you will be selecting text instead of moving the box.</p>
<p><em>The updated text only becomes part of the patch when you de-select the object.</em> Changing the text in an &quot;object&quot; box deletes the old object and creates a new one; the internal state of the old one is lost.</p>
<h3 id="226-connecting-and-disconnecting-boxes">2.2.6. connecting and disconnecting boxes</h3>
<p>To make a connection between two boxes, click on any outlet of the first one, drag toward an inlet of the second one, and release. You can release the mouse button anywhere within the target object and the connection will be made to the nearest inlet.</p>
<p>Connections are broken by selecting them and using &quot;cut&quot; or the backspace or delete key.</p>
<h3 id="227-popup-menu-for-properties-open-and-help">2.2.7. popup menu for properties, open, and help</h3>
<p>All the &quot;clicking&quot; mentioned above is done with the left mouse button. The right button, instead, gives a popup menu offering &quot;properties,&quot; &quot;open,&quot; and &quot;help&quot;. (For Macintosh users who may only have one button on their mouse, double-clicking is mapped to right-click.)</p>
<p>Selecting &quot;help&quot; on an object gets a Pd patch that demonstrates how to use it. &quot;Help&quot; for the canvas as a whole (right-clicking outside any object) gives a list of all built-in objects.</p>
<p>The &quot;open&quot; menu item is only enabled if you right-click on a subpatch (see below) and causes Pd to open it. Ordinary subpatches may also be opened by clicking on them, but for &quot;graph-on-parent&quot; ones, this is the only way to do it.</p>
<p>The &quot;properties&quot; dialog allows you to change certain settings of GUI objects, or of the patch itself (by clicking outside any box.)</p>
<h3 id="228-miscellaneous">2.2.8. miscellaneous</h3>
<p>Control-q &quot;quits&quot; Pd, but asks you to confirm the quit. To quit without having to confirm, use command-shift-Q.</p>
<h3 id="23-messages">2.3. messages</h3>
<p>In Pd, objects intercommunicate by sending messages and/or audio signals. Pd messages are sporadic, like MIDI messages or music N &quot;Note cards.&quot;</p>
<h3 id="231-anatomy-of-a-message">2.3.1. anatomy of a message</h3>
<p>Messages contain a selector followed by any number of arguments. The selector is a symbol, which appears in the patch as a non-numeric string with no white space, semicolons, or commas. The arguments may be symbols or numbers. Numbers in Pd are kept in 32-bit floating point, so that they can represent integers exactly between â16777216 and 16777216. (In Max, there are separate data types for integers and floating point numbers; Pd uses only float.)</p>
<p>When a message is passed to something (which is often an inlet of a box but could be anything that can receive a message), the selector of the message is checked against the receiver. If the receiver recognizes messages of that selector, it carries out some corresponding action. For instance, here is a &quot;float&quot; object:</p>
<p><img src="fig3.1.jpg" alt="float object"></p>
<p>The two rectangles at the top are usually both called &quot;inlets&quot; but the one at the left directs incoming messages to the &quot;float&quot; object itself, whereas the one at the right directs messages to an auxiliary &quot;inlet&quot; object. The float object proper (represented by the left-hand inlet) accepts messages with selector &quot;float&quot; and &quot;bang&quot;. The right-hand inlet takes only the message selector &quot;float&quot;. These two selectors, along with &quot;symbol&quot; and &quot;list&quot;, are usually used to denote an object&apos;s main action, whatever it may be, so that objects can be interconnected with maximum flexibility.</p>
<p>It is possible to type messages which start with a number, which cannot be used as a selector. A single number is always given the &quot;float&quot; selector automatically, and a message with a number followed by other arguments is given the selector &quot;list&quot;.</p>
<h3 id="232-depth-first-message-passing">2.3.2. depth first message passing</h3>
<p>In Pd whenever a message is initiated, the receiver may then send out further messages in turn, and the receivers of those messages can send yet others. So each message sets off a tree of consequent messages. This tree is executed in depth first fashion. For instance in the patch below:</p>
<p><img src="images/fig3.2.jpg" alt="depth first message passing"></p>
<p>the order of arrival of messages is either A-B-C-D or A-C-D-B. The &quot;C&quot; message is not done until the &quot;D&quot; one is also, and the &quot;A&quot; is not done until all four are. It is indeterminate which of &quot;B&quot; or &quot;C&quot; is done first; this depends on what order you made the connections in (in Max, it&apos;s automatically sorted right to left).</p>
<p>Message-passing can give rise to infinite loops of the sort shown here:</p>
<p><img src="images/fig3.3.jpg" alt="infinite message passing loop"></p>
<p>Here the left-hand &quot;+&quot; can&apos;t finish processing until the right-hand one has been sent the result &quot;2&quot;, which can&apos;t finish processing that until the left-hand one has been sent &quot;3&quot;, and so on. Pd will print an error message reporting a &quot;stack overflow&quot; if this happens.</p>
<p>However, it is legal to make a loop if there is a &quot;delay&quot; object somewhere in it. When the &quot;delay&quot; receives a message it schedules a message for the future (even if the time delay is 0) and is then &quot;finished;&quot; Pd&apos;s internal scheduler will wake the delay back up later.</p>
<h3 id="233-hot-and-cold-inlets-and-right-to-left-outlet-order">2.3.3. hot and cold inlets and right to left outlet order</h3>
<p>With few exceptions (notably &quot;timer&quot;), objects treat their leftmost inlet as &quot;hot&quot; in the sense that messages to left inlets can result in output messages. So the following is a legal (and reasonable) loop construct:</p>
<p><img src="images/fig3.4.jpg" alt="hot and cold inlets"></p>
<p>Here the &quot;f&quot; is an abbreviation for &quot;float&quot;. Note that the &quot;+ 1&quot; output is connected to the right-hand inlet of &quot;f&quot;. This &quot;cold&quot; inlet merely stores the value for the next time the &quot;f&quot; is sent the &quot;bang&quot; message.</p>
<p>It is frequently desirable to send messages to two or more inlets of an object to specify its action. For instance, you can use &quot;+&quot; to add two numbers; but to do it correctly you must make sure the right hand inlet gets its value first. Otherwise, when the left hand side value comes in, &quot;+&quot; will carry out the addition (since the left hand inlet is the &quot;hot&quot; one) and will add this value to whatever was previously sitting in the right hand inlet.</p>
<p>Problems can arise when a single outlet is connected (either directly or through arbitrarily long chains of message passing) to different inlets of a single object. In this case it is indeterminate which order the two inlets will receive their messages. Suppose for example you wish to use &quot;+&quot; to double a number. The following is incorrect:</p>
<p><img src="images/fig3.5.jpg" alt="incorrect inlet connection"></p>
<p>Here, I connected the left inlet before connecting the right hand one (although this is not evident in the appearance of the patch.) The &quot;+&quot; thus adds the new input (at left) to the previous input (at right).</p>
<p>The &quot;trigger&quot; object, abbreviated &quot;t&quot;, can be used to split out connections from a single outlet in a determinate order. By convention, all objects in Pd, when sending messages out more than one outlet, do so from right to left. If you connect these to inlets of a second object without crossing wires, the second object will get its leftmost inlet last, which is usually what you want. Here is how to use &quot;trigger&quot; to disambiguate the previous example:</p>
<p><img src="images/fig3.6.jpg" alt="trigger to disambiguate"></p>
<p>&quot;Cold&quot; (non-leftmost) inlets are almost universally used to store single values (either numbers or symbols.) With the exception of &quot;line&quot; and &quot;line~&quot;, these values are &quot;sticky,&quot; i.e., once you set the value it is good until the next time you set it. (The &quot;line&quot; exception is for sanity&apos;s sake.)</p>
<p>One more question sometimes comes up in execution order, which is the order in which two messages are sent to a single &quot;cold&quot; inlet. In this situation, since the messages are merged, the last value to be received is the value that is used in the computation.</p>
<h3 id="234-message-boxes">2.3.4. message boxes</h3>
<p>Message boxes are text boxes in which you type a message. When the message box is activated, either by clicking on it or sending something to its inlet, the message or messages are sent, either to the message box&apos;s outlet or elsewhere as specified.</p>
<p><img src="images/fig3.7.jpg" alt="message boxes"></p>
<p>The first of the message boxes above contains the single number 1.5; this message has an implicit selector of &quot;float.&quot; The second is a list with three numbers in it, and in the third, the selector is &quot;my&quot; and the two arguments are the number 5 and the symbol &quot;toes.&quot;</p>
<p>Multiple messages may be separated by commas as shown:</p>
<p><img src="images/fig3.8.jpg" alt="multiple messages in one box"></p>
<p>Here the three messages are the numbers 1, 2, and 3, and they are sent in sequence (with no intervening time between them, as with the &quot;trigger&quot; object, and having depth-first consequences so that whatever chain of actions depending on &quot;1&quot; takes place before anything depending on &quot;2&quot; and so on.)</p>
<p>Semicolons may also separate messages. A message following a semicolon must specify a symbol giving a destination (in other words, semicolons are like commas except that they clear the &quot;current destination&quot; so that the next message specifies a new one). The &quot;current destination&quot; is at first the message box&apos;s own outlet. In the example below, the leading semicolon immediately redirects messages from the outlet to an object named &quot;fred&quot; (which is here a receive object), and likewise the next message is sent to &quot;sue.&quot;</p>
<p><img src="images/fig3.9.jpg" alt="semicolons to send messages"></p>
<p>Certain other objects (Pd windows, for example, and arrays) have Pd names and can be sent messages this way. Also, the special object &quot;pd&quot; is defined to which you may send messages to start and stop DSP.</p>
<p>You can put variables in message boxes as shown below:</p>
<p><img src="images/fig3.10.jpg" alt="variables in message boxes"></p>
<p>Here, &quot;$1&quot;, etc., refer to the arguments of the arriving message (and aren&apos;t defined if you send a &quot;bang&quot; message or if you click on the message box to activate it.) Dollar sign variables are either numbers or symbols depending on the incoming message; if symbols, you may even use them to specify variable message selectors or destinations.</p>
<h3 id="24-audio-signals">2.4. audio signals</h3>
<p>Using Pd you can build audio patches which can synthesize musical sounds, analyze incoming sounds, process incoming sounds to produce transformed audio outputs, or integrate audio processing with other media. This section describes how Pd treats audio signals.</p>
<h3 id="241-sample-rate-and-format">2.4.1. sample rate and format</h3>
<p>Pd&apos;s audio signals are internally kept as 32-bit floating point numbers, so you have all the dynamic range you could want. However, depending on your hardware, audio I/O is usually limited to 16 or 24 bits. Inputs all appear between the values of -1 and 1; and output values will be clipped to that range. Pd assumes a sample rate of 44100 unless you override this ( in Pd&apos;s command line or in the &quot;audio setup&quot; dialog).</p>
<p>Pd can read or write samples to files either in 16-bit or 24-bit fixed point or in 32-bit floating point, in WAV, AIFF, or AU format, via the soundfiler, readsf, and writesf objects.</p>
<h3 id="242-tilde-objects-and-audio-connections">2.4.2. tilde objects and audio connections</h3>
<p>Audio computations in Pd are carried out by &quot;tilde objects&quot; such as &quot;osc~&quot; whose names conventionally end in a tilde character to warn you what they are. Tilde objects can intercommunicate via audio connections. When audio computation is turned on, or when you change the audio network while audio is on, Pd sorts all the tilde objects into a linear order for running; then this linear list is run down in blocks of 64 samples each; at 44100 Hz. this means the audio network runs every 1.45 milliseconds.</p>
<p>Inlets or outlets are configured in Pd either for messages or audio; it&apos;s an error to connect an audio outlet to a non-audio inlet or vice versa; usually these errors are detected at &quot;sort time&quot; when audio is started or the network changed with audio running. An object&apos;s leftmost inlet may accept both audio and messages; any other inlet is either one or the other.</p>
<p>The audio network, that is, the tilde objects and their interconnections, must be acyclic. If there are loops, you will see the error message at &quot;sort time.&quot; When errors are reported at sort time there is no easy way to find the source of the error. You can build algorithms with feedback using nonlocal signal connections.</p>
<p>Your subpatches can have audio inlets and outlets via the inlet~ and outlet~ objects.</p>
<h3 id="243-converting-audio-to-and-from-messages">2.4.3. converting audio to and from messages</h3>
<p>If you want to use a control value as a signal, you can use the sig~ object to convert it. The +~, -~, *~, /~, osc~, and phasor~ objects can be configured to take control or signal inputs.</p>
<p>The other direction, signal to control, requires that you specify at what moments you want the signal sampled. This is handled by the snapshot~ object, but you can also sample a signal with tabwrite~ and then get access it via tabread or tabread4 (note the missing tildes!). There are also analysis objects, the simplest of which is &quot;env~&quot;, the envelope follower.</p>
<h3 id="244-switching-and-blocking">2.4.4. switching and blocking</h3>
<p>You can use the switch~ or block~ objects to turn portions of your audio computation on and off and to control the block size of computation. There may be only one switch~ or block~ object in any window; it acts on the entire window and all of its subwindows, which may still have their own nested switch~/block~ objects. Switch~ and block~ take a block size and an overlap factor as arguments; so for instance, &quot;block~ 1024 4&quot; specifies 1024 sample blocks, overlapped by a factor of 4 relative to the parent window. Switch~ carries a small computational overhead in addition to whatever overhead is associated with changing the block size.</p>
<p>Larger block sizes than 64 should result in small increases in run-time efficiency. Also, the fft~ and related objects operate on blocks so that setting the block size also sets the number of FFT channels. You may wish to use block sizes smaller than 64 to gain finer resolutions of message/audio interaction, or to reduce &quot;block delay&quot; in feedback algorithms. At the (untested) extreme, setting the block size to one allows you to write your own recursive filters.</p>
<p>You can use switch~ to budget your DSP computations; for instance you might want to be able to switch between two synthesis algorithms. To do this, put each algorithm in its own subpatch (which can have sub-sub patches in turn, for a voice bank for instance), and switch each one off as you switch the other one on. Beware of clicks; if you have a line~ controlling output level, give it time to ramp to zero before you switch it off or it will be stuck at a nonzero value for the next time it comes back on.</p>
<p>When a subpatch is switched off its audio outputs generate zeros; this costs a fairly small overhead; a cheaper way to get outputs is to use throw~ inside the switched module and catch~ outside it.</p>
<h3 id="245-nonlocal-signal-connections">2.4.5. nonlocal signal connections</h3>
<p>You may wish to pass signals non-locally, either to get from one window to another, or to feed a signal back to your algorithm&apos;s input. This can be done using throw~/catch~, send~/receive~, or delwrite~/delread~ pairs. Throw~ and catch~ implement a summing bus; throw~ adds into the bus and catch~ reads out the accumulated signal and zeros the bus for the next time around. There can be many throw~ objects associated with a single catch~, but a throw~ can&apos;t talk to more than one catch~. You can reset the destination of a throw~ if you want to.</p>
<p>Send~ just saves a signal which may then be receive~d any number of times; but a receive~ can only pick up one send~ at a time (but you can switch between send~s if you want.)</p>
<p>Don&apos;t try to throw~ and catch~ or send~ and receive~ between windows with different block sizes. The only re-blocking mechanisms which are well tested are inlet~ and outlet~.</p>
<p>When you send a signal to a point that is earlier in the sorted list of tilde objects, the signal doesn&apos;t get there until the next cycle of DSP computation, one block later; so your signal will be delayed by one block (1.45 msec by default.) Delread~ and delwrite~ have this same restriction, but here the 1.45 msec figure gives the minimum attainable delay. For non-recursive algorithms, a simple flanger for example, you might wish to ensure that your delread~ is sorted after your delwrite~. The only way to ensure this is to create the delread~ after you created the delwrite~; if things get out of whack, just delete and re-create the delread~.</p>
<h3 id="25-scheduling">2.5. scheduling</h3>
<p>Pd uses 64-bit floating point numbers to represent time, providing sample accuracy and essentially never overflowing. Time appears to the user in milliseconds.</p>
<h3 id="251-audio-and-messages">2.5.1. audio and messages</h3>
<p>Audio and message processing are interleaved in Pd. Audio processing is scheduled every 64 samples at Pd&apos;s sample rate; at 44100 Hz. this gives a period of 1.45 milliseconds. You may turn DSP computation on and off by sending the &quot;pd&quot; object the messages &quot;dsp 1&quot; and &quot;dsp 0.&quot;</p>
<p>In the intervals between, delays might time out or external conditions might arise (incoming MIDI, mouse clicks, or whatnot). These may cause a cascade of depth-first message passing; each such message cascade is completely run out before the next message or DSP tick is computed. Messages are never passed to objects during a DSP tick; the ticks are atomic and parameter changes sent to different objects in any given message cascade take effect simultaneously.</p>
<p>In the middle of a message cascade you may schedule another one at a delay of zero. This delayed cascade happens after the present cascade has finished, but at the same logical time.</p>
<h3 id="252-computation-load">2.5.2. computation load</h3>
<p>The Pd scheduler maintains a (user-specified) lead on its computations; that is, it tries to keep ahead of real time by a small amount in order to be able to absorb unpredictable, momentary increases in computation time. This is specified using the &quot;audiobuffer&quot; or &quot;frags&quot; command line flags (see <a target="frame" href="x3.html">getting Pd to run</a> ).</p>
<p>If Pd gets late with respect to real time, gaps (either occasional or frequent) will appear in both the input and output audio streams. On the other hand, disk streaming objects will work correctly, so that you may use Pd as a batch program with soundfile input and/or output. The &quot;-nogui&quot; and &quot;-send&quot; startup flags are provided to aid in doing this.</p>
<p>Pd&apos;s &quot;realtime&quot; computations compete for CPU time with its own GUI, which runs as a separate process. A flow control mechanism will be provided someday to prevent this from causing trouble, but it is in any case wise to avoid having too much drawing going on while Pd is trying to make sound. If a sub-window is closed, Pd suspends sending the GUI update messages for it; but not so for miniaturized windows as of version 0.32. You should really close them when you aren&apos;t using them.</p>
<h3 id="253-determinism">2.5.3. determinism</h3>
<p>All message cascades that are scheduled (via &quot;delay&quot; and its relatives) to happen before a given audio tick will happen as scheduled regardless of whether Pd as a whole is running on time; in other words, calculation is never reordered for any real-time considerations. This is done in order to make Pd&apos;s operation deterministic.</p>
<p>If a message cascade is started by an external event, a time tag is given it. These time tags are guaranteed to be consistent with the times at which timeouts are scheduled and DSP ticks are computed; i.e., time never decreases. (However, either Pd or a hardware driver may lie about the physical time an input arrives; this depends on the operating system.) &quot;Timer&quot; objects which measure time intervals measure them in terms of the logical time stamps of the message cascades, so that timing a &quot;delay&quot; object always gives exactly the theoretical value. (There is, however, a &quot;realtime&quot; object that measures real time, with nondeterministic results.)</p>
<p>If two message cascades are scheduled for the same logical time, they are carried out in the order they were scheduled.</p>
<h3 id="26-semantics">2.6. semantics</h3>
<p>This section describes how objects in Pd are created, how they store data and how object and other boxes pass messages among themselves.</p>
<h3 id="261-creation-of-objects">2.6.1. creation of objects</h3>
<p>The text in a box has a different function depending on whether it is a message, atom (number/symbol), or object box. In message boxes the text specifies the message or messages it will send as output. In atom boxes the text changes at run time to show the state of the box, which is either a number or a symbol.</p>
<p>In an object box, as in a message box, the text specifies a message; but here the message is to be passed to Pd itself, once, and the message&apos;s effect is to create the object in question. When you open a file, all the objects created are created using their text as &quot;creation messages.&quot; If you type a new message into an object box (or change it), the old object is destroyed and the message is used to create the new one.</p>
<p>The selector of the message (the first word in the message) is a selector which Pd interprets to mean which type of object to create. Any message arguments (called &quot;creation arguments&quot;) are used to parameterize the object being created. Thus in &quot;makenote 64 250&quot; the selector &quot;makenote&quot; determines the class of object to create and the creation arguments 64 and 250 become the initial velocity and duration.</p>
<h3 id="262-persistence-of-data">2.6.2. persistence of data</h3>
<p>Among the design principles of Pd is that patches should be printable, in the sense that the appearance of a patch should fully determine its functionality. For this reason, if messages received by an object change its action, since the changes aren&apos;t reflected in the object&apos;s appearance, they are not saved as part of the file which specifies the patch and will be forgotten when the patch is reloaded. In the same way, if you delete and then recreate an object the original object&apos;s state is not retained but is instead reinitialized (possibly as specified by creation arguments.)</p>
<p>An exception is made for subpatches whose &quot;state&quot; is the configuration of the subpatch; as a special case, this configuration is restored when the patch is read from a file. Also, if you rename the subpatch, for instance typing &quot;pd jane&quot; instead of &quot;pd spot,&quot; the contents of the patch are preserved and only the text in the object box and the window title of the subpatch are changed.</p>
<p>It is probably bad style to specify creation arguments ala &quot;makenote 64 250&quot; if you are going to override them later; this is confusing to anyone who tries to understand the patch.</p>
<h3 id="263-message-passing">2.6.3. message passing</h3>
<p>Messages in Pd consist of a selector (a symbol) and zero or more arguments (which may be symbols or numbers). To pass a message to an object, Pd first checks the selector against the class of the object. Message boxes all are of one class and they all take the same incoming messages and dispense them according to their state, that is, the text typed into the box. The same holds for atom boxes (number or symbol) except that their state may change (it consists of the number or symbol showing).</p>
<p>Object boxes may have many different classes. The class is usually determined by the selector of the creation message, i.e., the first atom of the creation message which is usually a symbol.</p>
<p>Each class comes with a fixed collection of messages it may be sent. For example, the &quot;float&quot; or &quot;f&quot; object takes &quot;bang&quot; and &quot;float.&quot; These messages are sent to &quot;float&quot; objects (objects whose class is float) via the leftmost, hot inlet. (The right inlet is a separate, auxiliary object.) Objects of class &quot;float&quot; respond to the message &quot;bang&quot; by outputting their current value, that is, by sending a &quot;float&quot; message to their outlet. They respond to &quot;float&quot; messages by setting their value and then outputting it.</p>
<p>Each other class (like &quot;float&quot;) in Pd has its own protocol for responding to messages it is sent, and may take &quot;float&quot; and &quot;bang&quot; messages, or others in addition or instead of them.</p>
<h3 id="264-inlets-and-lists">2.6.4. inlets and lists</h3>
<p>The leftmost connection point at the top of most objects represents the object itself. Any other dark rectangle is a separate object called an &quot;inlet&quot; although in Pd there are 4 individual inlet classes. The class of the inlet determines which messages it will take: symbol, float, or other; and the inlet forwards the message either to the object proper or to some proxy, usually one that the object creates for the occasion.</p>
<p>Unless they arrange otherwise by defining a &quot;list&quot; method, objects respond to the &quot;list&quot; message by distributing the arguments of the message to their inlets, except for the first argument which is passed as a &quot;float&quot; or &quot;symbol&quot; message to the object proper.</p>
<h3 id="265-dollar-signs">2.6.5. dollar signs</h3>
<p>In message or object boxes, message arguments starting with a dollar sign and a number (like &quot;$1&quot; or &quot;$3-bazoo&quot;) are variables which are substituted with values supplied as part of the environment the message is passed in. In the case of message boxes, the environment consists of the arguments of the &quot;list&quot; message (possibly extrapolated from &quot;bang,&quot; &quot;float,&quot; or other) that the message box is responding to. Thus, if a message box gets &quot;23 skidoo&quot; and if it contains the text, &quot;$2 until $1,&quot; out comes the message, &quot;skidoo until 23.&quot;</p>
<p>Object boxes contain text which forms a message to be sent to Pd to create and initialize the object. Here, $1, etc., are taken from the context in which the patch was loaded. When the patch is a new document or opened from a file the &quot;$&quot; variables are undefined. But if the patch is an abstraction (see the next section) they are taken from the abstractions&apos; creation arguments.</p>
<p>Constructions such as &quot;$1-x&quot; are expanded by string concatenation. This is the mechanism for making local variables. In particular, $0 is a counter, where every patch gets its own value. In an abstraction this guarantees a unique ID number to that abstraction, so sends and receives with names like &quot;$0-bear&quot; can be used as local send/receive pairs. This is also useful for things like array names, value names and text names (as defined in the text object).</p>
<p>Occasionally you may want to have double or triple substitutions; this can be done one stage at a time by nesting abstractions (with each subpatch adding its own $-variable to a symbol and passing that on as argument to a further abstraction.)</p>
<p>For example, if you want to get dog-food, dog-ears, and cat-food, for example, have an abstraction &quot;a1&quot; that invokes an abstraction &quot;a2&quot; twice, as &quot;a2 $1-food&quot; and &quot;a2 $1-ears&quot;, and then in a third patch call a1 twice, as &quot;a1 cat&quot; and &quot;a1 dog&quot;. Inside the four &quot;a2&quot; copioes, $1 will evaluate to &quot;dog-food&quot;, &quot;cat-food&quot;, &quot;dog-ears&quot;, and &quot;cat-ears&quot;.</p>
<h3 id="27-subpatches">2.7. subpatches</h3>
<p>Pd offers two mechanisms for making subpatches, called &quot;one-off subpatches&quot; and &quot;abstractions.&quot; In either case the subpatch appears as an object box in a patch. If you type &quot;pd&quot; or &quot;pd my-name&quot; into an object box, this creates a one-off subpatch. For instance, in this fragment:</p>
<p><img src="images/fig7.1.jpg" alt="subpatch"></p>
<p>the box in the middle, if clicked on, opens the sub-patch shown here:</p>
<p><img src="images/fig7.2.jpg" alt="open subpatch window"></p>
<p>The contents of the subpatch are saved as part of the parent patch, in one file. If you make several copies of a subpatch you may change them individually.</p>
<p>The objects, &quot;inlet,&quot;, &quot;inlet~,&quot; &quot;outlet,&quot; and &quot;outlet~,&quot;, when put in a subpatch, create inlets and outlets for the object box containing the subpatch. This works equally for one-off subpatches and abstractions and only accept control data messages. The inlet~ and outlet~ versions create inlets and outlets for audio signals. Note you can also mix control messages in an inlet~ with the &apos;fwd&apos; argument but a signal outlet only takes signals. Inlets and outlets appear on the invoking box in the same left-to-right order as they appear in the subpatch.</p>
<h3 id="271-abstractions">2.7.1. abstractions</h3>
<p>To make an abstraction, save a patch with a name such as &quot;abstraction1.pd&quot; and then invoke it as &quot;abstraction1&quot; in an object box:</p>
<p><img src="images/fig7.3.jpg" alt="abstraction"></p>
<p>Here we&apos;re invoking a separate file, &quot;abstraction1.pd&quot;, which holds the patch shown here (the border is the same as for the subpatch above):</p>
<p><img src="fig7.4.jpg" alt="abstraction example"></p>
<p>You may create many instances of &quot;abstraction1&quot; or invoke it from several different patches; and changing the contents of &quot;abstraction1&quot; will affect all invocations of it as they are created. An analogy from the &quot;c&quot; programming language is that one-off subpatches are like bracketed blocks of code and abstractions are like subroutines.</p>
<p>Abstractions are instantiated by typing the name of a patch (minus the &quot;.pd&quot; extension) into an object box. You may also type arguments; for instance if you have a file &quot;my-abstraction.pd&quot; you may type &quot;my-abstraction 5&quot; to set the variable $1 to 5. This is defined only for object boxes (not for messages) in the abstraction. (For message boxes, &quot;$1&quot;, etc, have a different meaning as described above.) If you want to send a message with a $1 in the sense of a creation argument of an abstraction, you must generate it with an object box such as &quot;float $1&quot;, &quot;symbol $1&quot;, or perhaps &quot;pack $1 $2&quot;, which may then be sent to a message box.</p>
<p>The corresponding feature in Max (both Opcode and Ircam) was the &quot;#1&quot; construct. In a Max abstraction, &quot;#1&quot;, etc., are replaced by the creation argument. This has the disadvantage that you can&apos;t edit the abstraction as instantiated in the patch since the &quot;#&quot; variables are substituted. In Pd the &quot;$&quot; variables in object boxes are spelled literally as &quot;$&quot; variables so that it&apos;s meaningful to edit them from within their calling patch. On the Pd side, however, there is the disadvantage that it&apos;s confusing to have &quot;$&quot; expanded at a different time in an object box than in a message box. In an object box, the &quot;$&quot; argument is expanded at creation time, and in a message box, at message time.</p>
<h3 id="272-graph-on-parent-subpatches">2.7.2. Graph-on-parent subpatches</h3>
<p>If you open the &quot;properties&quot; dialog for a subpatch or an abstraction, you can check the &quot;graph on parent&quot; box to have the controls of the subpatch/abstraction appear on the parent. For instance, here is an invocation of &quot;abstraction2&quot;:</p>
<p><img src="images/fig7.5.jpg" alt="graph-on-parent abstraction"></p>
<p>where the patch &quot;abstraction2.pd&quot; contains:</p>
<p><img src="images/fig7.6.jpg" alt="inside graph-on-parent abstraction"></p>
<p>Here, the number box in the abstraction shows up on the box that invoked the abstraction. The &quot;graph on parent&quot; flag is set in the abstraction (and is saved as part of the abstraction); to set it, open the &quot;properties&quot; dialog for the &quot;abstraction2&quot; canvas by right-clicking on any white space in the patch.</p>
<p>To open the subpatch, right click on the object and select &quot;open&quot;. (On Macintoshes without a 2-button mouse, you can double-click in edit mode instead.) It doesn&apos;t work just to click on the object in run mode since clicks are sent to visible controls and/or arrays.</p>
<p>When the sub-patch is closed, all controls in it appear on the object instead; so the number box in the sub-patch in the example above is the same one as you see in the box. Only controls are made visible in this way</p>
<h3 id="28-numeric-arrays">2.8. numeric arrays</h3>
<p>Linear arrays of numbers recur throughout the computer musician&apos;s bag of tricks, beginning with the wavetable oscillator. The wavetable oscillator later was reinvented as the looping sampler. Also, table lookup is used for nonlinear distortion of audio signals. In the domain of control, arrays of numbers can specify control mappings, probability densities, voicing data, and much more.</p>
<p>Arrays in Pd should be allocated (and possible read in from a file) before beginning to make sound, since memory allocation and disk operations may take long enough to cause audio buffer overruns or underruns. Pd provides two ways to define new arrays, as &quot;graphs&quot; and &quot;tables&quot;. In either case the array has a pre-defined name and size (i.e., number of points). Elements of the array are stored as floating-point numbers, 4 bytes apiece</p>
<p>If you use an array to store a one-second sound at 44.1 kHz you will need 176 kilobytes, or a one-minute sound, 10.6 megabytes. To store a sound with two or more channels, use a separate array for each channel.</p>
<p>Arrays are also useful as transfer functions, for example for nonlinear distortion of an audio signal, or to map a control onto a synthesis parameter. In situations like this one typically uses much shorter arrays, of no more than a few hundred elements. They are also useful for storing measured spectra derived from the fft~ objects, and probably for many other uses.</p>
<p>Arrays usually appear within subpatches created to house them, whether in &quot;graph on parent&quot; form (so that you see them within a rectangle drawn on the containing patch), or as a regular subpatch (which you see as a text box.) In the &quot;graph on parent&quot; form, an array appears as shown:</p>
<p><img src="images/fig8.1.jpg" alt="array"></p>
<p>Arrays are indexed from 0 to N-1 where N is the number of points in the array. You can read an array value using the tabread object:</p>
<p><img src="images/fig8.2.jpg" alt="array indexing"></p>
<p>Here we see that the third point of the array (index 2) has the value 0.4. To write into the array you can use the tabwrite object:</p>
<p><img src="images/fig8.3.jpg" alt="setting an value in an array"></p>
<p>In this example, sending the message sets the third element to 0.5. (You may also send the two numbers to the two inlets separately.)</p>
<p>The two previous examples showed control operations to read and write from and to arrays. These may also be done using audio signals. For example, the patch below creates a 440 Hz. tone with &quot;array1&quot; as a waveform:</p>
<p><img src="images/fig8.4.jpg" alt="setting an array with a waveform"></p>
<p>Here phasor~&apos;s outputs a sawtooth wave, repeating 440 times per second, whose output range is from 0 to 1. The multiplier and adder adjust the range from 1 to 11, and then the values are used as indices for tabread4~, which is a 4-point interpolating table lookup module. (Much more detail is available in the audio example patches in the &quot;pure documentation&quot; series.)</p>
<p>To create a new array, select &quot;array&quot; from the &quot;put&quot; menu. Up will come a dialog window to set initial properties of the array. By default, a new graph is created to hold the array, but it may also be housed in the most recently created graph instead. Other properties may be specified there and/or changed later using the &quot;properties&quot; dialog.</p>
<p>If you select &quot;properties&quot; on an array in a graph, you two dialogs, one for the array and one for the graph. The array dialog looks like this:</p>
<p><img src="images/fig8.5.jpg" alt="array properties window"></p>
<p>You may use this to change the name and size, in addition to another property, &quot;save contents&quot;. If &quot;save contents&quot; is selected, the array&apos;s values are stored in the containing patch; otherwise they&apos;re initialized to zero each time the patch is reloaded. If you intend to use arrays to store sounds, you will probably not wish to store them in the patch but as separate soundfiles. This will be more efficient, and you may also then use a sound editor to modify them outside Pd.</p>
<p>If you check &quot;delete me&quot; and then &quot;OK&quot;, the array will be deleted. This is an odd interface for deleting an object, and is only provided because Pd lacks a mechanism for selecting arrays (so that &quot;cut&quot; could serve).</p>
<p>The graph dialog (which also pops up) is shown here:</p>
<p><img src="images/fig8.6.jpg" alt="graph properties"></p>
<p>The X bounds initially range from 0 to the number of points in the table minus one (this is a good choice for arrays, although graphs holding other kinds of objects might require other X bounds.) The Y bounds should be chosen to reflect the natural range of the table, so that stored sounds would naturally range from -1 to 1, but a sequence of frequency values might range from 0 to 20,000. Finally, you choose the screen size of the graph, width and height, in screen pixels.</p>
<p>Many other operations are defined for arrays; see the related patches in the tutorial (starting at 2.control/15.array.pd) for more possibilities.</p>
<h3 id="29-data-structures">2.9. Data structures</h3>
<p>(Note: this section is adapted from an article submitted to ICMC 2002.)</p>
<p>The original idea in developing Pd was to make a real-time computer music performance environment like Max, but somehow to include also a facility for making computer music scores with user-specifiable graphical representations. This idea has important precedents in Eric Lindemann&apos;s Animal and Bill Buxton&apos;s SSSP. An even earlier class of precedents lies in the rich variety of paper scores for electronic music before it became practical to offer a computer-based score editor. In this context, scores by Stockhausen ( <em>Kontakte</em> and <em>Studie II</em>) and Yuasa (<em>Toward the Midnight Sun</em>) come most prominently to mind, but also Xenakis&apos;s <em>Mycenae-alpha</em>, which, although it was realized using a computer, was scored on paper and only afterwards laboriously transcribed into the computer.</p>
<p>Pd is designed to to offer an extremely unstructured environment for describing data structures and their graphical appearance. The underlying idea is to allow the user to display any kind of data he or she wants to, associating it in any way with the display. To accomplish this Pd introduces a graphical data structure, somewhat like a data structure out of the C programming language, but with a facility for attaching shapes and colors to the data, so that the user can visualize and/or edit it. The data itself can be edited from scratch or can be imported from files, generated algorithmically, or derived from analyses of incoming sounds or other data streams. Here is one simple example of a very short musical sketch realized using Pd:</p>
<p><img src="images/fig9.1.jpg" alt="graphical score"></p>
<p>The example, which only lasts a few seconds, is a polyphonic collection of time-varying noise bands. The graphical &quot;score&quot; consists of six objects, each having a small grab point at left, a black shape to show dynamic, and a colored shape to show changing frequency and bandwidth. The horizontal axis represents time and the vertical axis, frequency (although, as explained later, this behavior isn&apos;t built into pd). The dynamic and frequency shapes aren&apos;t constrained to be connected or even to be proximate, but since they pertain to the same sound their horizontal positions line up. In this example the last (furthest-right) object is percussive (as seen by the black shape) and has a fixed frequency and bandwidth, whereas the large, articulated shape in the center has a complicated trajectory in both frequency and dynamic. The color of the frequency trace determines the voice number used to realize it.</p>
<p>Each object is thus composed of a combination of scalar values (color; aggregate position in X and Y coordinates) and array values (time/value pairs for the black traces and time/frequency/bandwidth triples for the colored ones.) This is all specified by the user using Pd&apos;s &quot;template&quot; mechanism.</p>
<p>Here is the template associated with the graphical objects shown above:</p>
<p><img src="images/fig9.2.jpg" alt="template for graphical score"></p>
<p>Templates consist of a data structure definition (the &quot;struct&quot; object) and zero or more drawing instructions (&quot;filledpolygon&quot; and &quot;plot&quot;). The &quot;struct&quot; object gives the template the name, &quot;template-toplevel.&quot; The data structure is defined to contain three floating point numbers named &quot;x&quot;, &quot;y&quot;, and &quot;voiceno,&quot; and two arrays, one named &quot;pitch&quot; whose elements belong to another template named &quot;template-pitch,&quot; and similarly for the array &quot;amp.&quot;</p>
<p>In general, data structures are built from four data types: scalar floats and symbols, arrays (whose elements share another, specified template) and lists (whose elements may have a variety of templates). The contents of a Pd window themselves form a list. Pd&apos;s correlate of Max&apos;s &quot;table&quot; object is implemented as a top-level array whose elements are scalars containing a single floating-point number.</p>
<p>Data structures in Pd may nest arbitrarily deeply using the array and list types. For example, a collection of sinusoidal tracks from an analysis engine could be implemented as an array of arrays of (pitch, amplitude) pairs; this appears as example 12 in Pd&apos;s FFT object online tutorial.</p>
<p>After the &quot;struct&quot; object in the template shown above, the remaining three objects are <em>drawing instructions</em> , first for a rectangle (&quot;filledpolygon&quot;), and then for two arrays. The various graphical attributes that are specified for drawing instructions may be numerical constants or data structure field names; in the latter case the value varies depending on the data. For instance, the second creation argument to &quot;plot&quot; is the color. The first &quot;plot&quot; plots the &quot;amp&quot; field and the color is given as 0, or black. The second one plots &quot;pitch&quot; using the color &quot;voiceno&quot;. In this way the color of the second trace is attached to the &quot;voiceno&quot; slot in the data structure, so that color will vary according to its &quot;voiceno&quot; slot.</p>
<h3 id="291-traversal">2.9.1. Traversal</h3>
<p>Pd objects are provided to traverse lists and arrays, and to address elements of data structures for getting and setting. Here is a patch showing how these facilities could be used, for example, to sequence the graphical score shown above:</p>
<p><img src="images/fig9.3.jpg" alt="traversal example patch"></p>
<p>Pd has no built-in sequencer, nor even any notion that &quot;x&quot; values should be used as a time axis. (However, a &quot;sort&quot; function is provided, which reorders a list from left to right, on the assumption that users might often want to use Pd data collections as x-ordered sequences.) Recording sequences of events into lists, and/or playing the lists back as sequences, are functionalities that the user is expected to supply on top of Pd&apos;s offerings, which, it is hoped, would allow those functionalities within a much larger range of possibilities, to include random re-orderings of events, score following, self-modifying scores, reactive improvisation, and perhaps much more.</p>
<p>Traversal of data is made possible by adding a new type of atom, &quot;pointer&quot;, to the two previously defined types that make up messages (numbers and symbols). Unlike numbers and symbols, pointers have no printed form and thus can&apos;t be uttered in message boxes. Traversal objects such as &quot;pointer&quot; and &quot;get&quot; (among several others) can generate or use pointers. The pointer data type is also integrated into pipe-fitting objects such as &quot;pack&quot;, &quot;unpack&quot;, and &quot;route&quot;.</p>
<p>In the patch shown above, the topmost &quot;pointer&quot; object holds a pointer to the next object to &quot;play&quot; (by sending it to one of the &quot;voice&quot; abstractions at bottom.) The pointer object takes a &quot;traverse&quot; message to set it to the head of the list (named &quot;pd-data&quot;), and &quot;next&quot; messages to move to (and output) the next datum in the list (i.e., the next in the list of six objects in the score). Another &quot;pointer&quot; object is also used, further down, as a storage cell for pointers just as &quot;float&quot; is for numbers.</p>
<p>The center of any sequencer is always the &quot;delay&quot; object, which must be fed the time difference between each event (including the non-event of hitting &quot;start&quot;) and the next. As we extract each of the six objects in the score, we must wait the delay for playing that object, and then send its pointer to one of the &quot;voice&quot; abstractions to play it. However, we have to inspect the object itself to know the delay before playing it. So, in the loop, we peel off the first remaining object to play and inspect the time difference between it and the previous one, using this value to set the delay, but also storing the pointer in the lower &quot;pointer&quot; and &quot;pack&quot; objects.</p>
<p>The time difference needed to set the delay object is obtained using the &quot;get template-toplevel x&quot; object. (This is converted to incremental time (&quot;-&quot;), corrected for tempo, and fed to the delay.) Pd provides the &quot;get&quot; and &quot;set&quot; objects for reading and writing values from data structures. The two &quot;get&quot; objects shown here obtain the &quot;x&quot; and &quot;voiceno&quot; fields of the current object. The template name (template-toplevel) is supplied to the &quot;get&quot; objects so that they can look up the offset of the necessary field(s) in advance, for greater run-time efficiency.</p>
<p>Once the delay has expired, the object&apos;s pointer is recalled (the lower &quot;pointer&quot; object), and the voice number is recalled. This is packed with the pointer itself and routed, so that the pointer goes to the appropriate voice. The voice number is shown as the color of the frequency trace in &quot;999&quot; units (first digit red, second green, third blue) and the &quot;route&quot; is arbitrarily set up to select among the six primary and secondary colors plus black.</p>
<p>The details of extracting the pitch and dynamic breakpoints from the arrays defined in the template are managed in the &quot;voice&quot; abstraction. The &quot;voice&quot; abstraction receives a pointer to a given object and manages the sequencing of the arrays; so it contains two sequencers itself. The nesting of the overall structure of the sequencer patch mirrors the nesting of the original data structures. Finally, the voice abstraction puts its audio output on a summing bus.</p>
<p>More general patches can easily be constructed which access heterogeneous lists of objects (having different templates). In this way, an arbitrarily rich personal &quot;score language&quot; can be developed and sequenced.</p>
<h3 id="292-accessing-and-changing-data">2.9.2. Accessing and changing data</h3>
<p>In general, accessing or changing data is done via &quot;pointers&quot; to &quot;scalars&quot;. Numbers and symbols within scalars are accessed using the &quot;get&quot; object and changed, in the same way, using &quot;set&quot;. Since lists and arrays are composed of scalars, every actual number or symbol in a data heap will be a number or symbol element of some scalar. To access them, it suffices to have objects to chase down elements of lists and arrays (given either a global name or a pointer to the containing scalar).</p>
<p>Lists are traversed in the way shown above; to get to a sublist of a scalar, the &quot;get&quot; object will provide a pointer, in the same way as it provides &quot;float&quot; or &quot;symbol&quot; elements of scalars. For arrays, an &quot;element&quot; object is provided which, given a scalar, a field name and a number, chases down the numbered, scalar, element of the named array field.</p>
<p>To alter &quot;float&quot; or &quot;symbol&quot; elements of scalars is straightforward using the &quot;set&quot; object, but arrays and lists can&apos;t be set by assignment; there is no suitable data type available within messages. Lists could possibly be &quot;settable&quot; by passing pointers to other lists, but permitting this would have required either automatically doing deep copies of data structures to carry out the assignments, or else implementing a garbage collecting memory management system, either of which would be difficult to realize within real-time computation time constraints. Instead, all the data hanging from a scalar is considered as belonging to that scalar, and is left in memory until the scalar is deleted; the data may be changed atom by atom, but primitives are not provided which would imply unpredictable execution times.</p>
<p>The &quot;getsize&quot; and &quot;setsize&quot; objects are provided to access or change the number of elements in the array. For lists, an &quot;append&quot; object appends a new scalar for a given template to a list, after the element pointed to. (To insert a scalar at the beginning of a list, the pointer can be set to the &quot;head&quot; of the list, a formal location before the first list item.) Deletion is less flexible; the only operation is to delete an entire list. (There&apos;s no reason not to provide finer-grain deletion mechanisms except that it&apos;s not clear how to protect against stale pointers efficiently, except by voiding the entire collection of pointers into a list.)</p>
<h3 id="293-editing">2.9.3. Editing</h3>
<p>The graphical score shown above can be edited by dragging breakpoints, or by adding and deleting them, using mouse clicks. Also, entire objects or collections of them may be copied, pasted, and dragged around the screen. Alternatively, there is an editable (or computer generate-able or parse-able) text representation for the data, which may be seen or changed in a dialog window or read and written to external text files.</p>
<p>Since the graphical presentation of data objects is determined by drawing instructions, the drawing instructions are interpreted backward to alter data as a result of mouse operations. If a given graphical dimension is controlled by a variable, that variable is then controlled by dragging along that dimension; if the dimension is constant, it can&apos;t be altered by dragging.</p>
<p>Tricky situations can arise when the user changes the contents of templates. A change in drawing instructions can be accommodated by simply tracking down and redrawing all data objects using the template. However, changing the &quot;struct&quot; object itself make for less straightforward situations. The user might wish to reorder fields, delete them, add new ones, or rename them. When a &quot;struct&quot; object changes, Pd automatically conforms the data from the old structure to the new one. Fields with the same name as previously are maintained (reordering them as necessary); and if a field disappears but another of the same type appears, the new one(s) are taken to be renamings of the old one(s) in order of appearance. New fields which cannot be matched in this way with previously existing ones are assumed to be new and are initialized.</p>
<p>It can happen that two &quot;struct&quot; objects compete to define the same data structure, or that the user reads in data from a file which expects a different version of the structure, or alternatively, that the &quot;struct&quot; object for existing data objects disappears. For this reason, Pd maintains a private representation of the last active version of a &quot;struct&quot; until all similarly named &quot;structs,&quot; as well as all data using that &quot;struct&quot;, have disappeared. If the user introduces a new version of the &quot;struct&quot; and only later deletes the &quot;current&quot; one, the data is only conformed to the new version once the old one is deleted. In this way we avoid getting into situations where data is left hanging without its structure definition, or where data ends up belonging to two or more structures of the same name. The worst that can happen is that data may lose their drawing instructions, in which case Pd supplies a simple default shape.</p>
<h3 id="294-limitations">2.9.4. Limitations</h3>
<p>When examples get more complicated and/or dense than the one shown here, it becomes difficult to see and select specific features of a data collection; more work is needed to facilitate this. There should be some facility for turning drawing instructions on and off, or perhaps for switching between versions of a template, depending on the user&apos;s desired view. There should also be a callback facility in the template for when an object is edited with the mouse, so that the user can bind actions to mouse clicks.</p>
<p>More generally, the collection of traversal objects that Pd provides is adequate to support a variety of modes of data collection and use, such as analysis and sequencing. But the patches required to traverse the data collections are not always simple. It would be desirable to find a more straightforward mechanism than that provided by the &quot;pointer&quot;, &quot;get&quot; and &quot;set&quot; objects.</p>
<p>The &quot;data&quot; facility, although part of the original plan for Pd, has only recently been implemented in its current form, and as (hopefully) the user base grows there will surely be occasions for many further extensions of the data handling primitives and the graphical presentation and editing functions.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                
                <a target="frame" href="PdM_Externals.html" class="navigation navigation-next navigation-unique" aria-label="Next page: Externals">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Theory of operation","level":"2.1.1","depth":2,"next":{"title":"Externals","level":"2.1.2","depth":2,"path":"PdM_Externals.md","ref":"PdM_Externals.md","articles":[]},"previous":{"title":"Pd Manual","level":"2.1","depth":1,"ref":"","articles":[{"title":"Theory of operation","level":"2.1.1","depth":2,"path":"PdM_TheoryOfOperation.md","ref":"PdM_TheoryOfOperation.md","articles":[]},{"title":"Externals","level":"2.1.2","depth":2,"path":"PdM_Externals.md","ref":"PdM_Externals.md","articles":[]}]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"PdM_TheoryOfOperation.md","mtime":"2023-03-08T19:13:28.072Z","type":"markdown"},"gitbook":{"version":"4.0.4","time":"2023-03-08T22:07:43.078Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

