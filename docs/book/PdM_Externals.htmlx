
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>4. Externals · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 4.0.4">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    
    <link rel="prev" href="PdM_Run.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    Setup
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" >
            
                <span>
            
                    
                    DAW Integration
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1.1" data-path="Setup_Ableton.html">
            
                <a href="Setup_Ableton.html">
            
                    
                    1. Ableton
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.2" data-path="Setup_Bitwig.html">
            
                <a href="Setup_Bitwig.html">
            
                    
                    2. Bitwig Studio
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.3" data-path="Setup_Reaper.html">
            
                <a href="Setup_Reaper.html">
            
                    
                    3. Reaper
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="2.1" >
            
                <span>
            
                    
                    Pd Manual
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.1.1" data-path="PdM_Introduction.html">
            
                <a href="PdM_Introduction.html">
            
                    
                    1. Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.2" data-path="PdM_TheoryOfOperation.html">
            
                <a href="PdM_TheoryOfOperation.html">
            
                    
                    2. Theory of operation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.3" data-path="PdM_Run.html">
            
                <a href="PdM_Run.html">
            
                    
                    3. Getting Pd to run
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="2.1.4" data-path="PdM_Externals.html">
            
                <a href="PdM_Externals.html">
            
                    
                    4. Externals
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >4. Externals</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <p>  Pd Manual 4   </p>
<h2 id="pd-manual-chapter-4-externals">Pd Manual chapter 4: externals</h2>
<h3 id="4-externals">4. Externals</h3>
<p>This section explains what are external objects and libraries. It also describes everything on how to install and load them in Pure Data.</p>
<p>You can write your own external objects that you and others can use in their Pd applications in C or (if you&apos;re smart and brave) in C++ or FORTRAN. In the &quot;6.externs&quot; subdirectory of the documentation you can find simple examples of externals with their source code and test patches.</p>
<p>There’s also an excellent guide to writing externals project by IOhannes zmölnig at <a href="https://github.com/pure-data/externals-howto" target="_blank">https://github.com/pure-data/externals-howto</a>. Check also the pd-lib-builder project (a helper makefile for Pure Data external libraries by Katja Vetter) at <a href="http://github.com/pure-data/pd-lib-builder" target="_blank">http://github.com/pure-data/pd-lib-builder</a></p>
<h3 id="41-external-objects--libraries">4.1 External Objects &amp; Libraries</h3>
<h3 id="411-what-are-vanilla-objects-internals--externals">4.1.1 What are: Vanilla Objects, Internals &amp; Externals?</h3>
<p>Internal objects come as part of the Pd binary, whereas external objects are separate from it. The main Pd distribution (a.k.a. “Pd Vanilla”) also comes with a few “extra” objects that are not part of its binary. Therefore, the set of “vanilla objects” (the built-in objects in Pd) include internals and externals. Nonetheless, “externals” mostly refer objects not available in the Pd Vanilla distribution, that you need to download and install them properly so they can be loaded into Pd patches.</p>
<p>To get a full list of all objects in Pd Vanilla, go to the <strong>Help</strong> menu and then select <strong>List of Objects</strong>, or alternatively right click on an empty spot of a patch’s window and select “help” - this loads the help-intro.pd file (see below).</p>
<p><img src="fig4.1.png" alt>  </p>
<p>The set of externals that come with Pd are available in the ‘extra’ library and is located in a folder named “extra” inside the Pd application. These appear at the very end of the “help-intro.pd” and can also be viewed in the Help Browser menu (Help =&gt; Browser). See figure below, which shows how the browser looks in a fresh install of Pd and lists the objects in the extra folder.</p>
<p><img src="fig4.2.png" alt>  </p>
<h3 id="412-what-are-the-types-of-external-objects">4.1.2. What are the Types of External Objects?</h3>
<p>An object in Pd can be either a patch - meaning a Pd file (a.k.a abstraction) - or a compiled binary (note that a binary can contain only one or several external objects, as discussed further on).</p>
<h3 id="4121-compiled-objects">4.1.2.1. Compiled objects:</h3>
<p>These are Pd objects compiled to binaries from programming code (like in C or C++). They have to be compiled for your operating system, which means the binaries have different extensions according to each platform. For instance:</p>
<p>Operating System</p>
<p>CPU-architecture</p>
<p>filename</p>
<p>Linux</p>
<p><em>unspecified</em> (any architecture)</p>
<p><code>my_lib.pd_linux</code></p>
<p>Linux</p>
<p>i386 (Intel/AMD 32bit)</p>
<p><code>my_lib.l_i386</code></p>
<p>Linux</p>
<p>amd64 (Intel/AMD 64bit)</p>
<p><code>my_lib.l_amd64</code></p>
<p>Linux</p>
<p>arm (e.g. RaspberryPi)</p>
<p><code>my_lib.l_arm</code></p>
<p>Linux</p>
<p>arm64</p>
<p><code>my_lib.l_arm64</code></p>
<p>macOS</p>
<p><em>unspecified</em> (any architecture)</p>
<p><code>my_lib.pd_darwin</code></p>
<p>macOS</p>
<p>fat (multiple archs)</p>
<p><code>my_lib.d_fat</code></p>
<p>macOS</p>
<p>PowerPC</p>
<p><code>my_lib.d_ppc</code></p>
<p>macOS</p>
<p>i386 (Intel 32bit)</p>
<p><code>my_lib.d_i386</code></p>
<p>macOS</p>
<p>amd64 (Intel 64bit)</p>
<p><code>my_lib.d_amd64</code></p>
<p>macOS</p>
<p>arm64 (Apple Silicon)</p>
<p><code>my_lib.d_arm64</code></p>
<p>Windows</p>
<p><em>unspecified</em> (any architecture)</p>
<p><code>my_lib.dll</code></p>
<p>Windows</p>
<p>i386 (Intel/AMD 32bit)</p>
<p><code>my_lib.m_i386</code></p>
<p>Windows</p>
<p>amd64 (Intel/AMD 64bit)</p>
<p><code>my_lib.m_amd64</code></p>
<h3 id="4122-abstractions">4.1.2.2. Abstractions:</h3>
<p>You can have a Pd patch behave like an object by loading it into other patches - these are usually called “abstractions”. Note that some of the externals in “extra” are abstractions (for instance, rev1~ or hilbert~). Like any other Pd patch, an abstraction may contain any kind of objects (internals, compiled externals and even other abstractions).</p>
<h3 id="413-what-are-external-libraries">4.1.3. What are External Libraries?</h3>
<p>In practical terms, an external library is a collection of external objects of any kind (abstractions or compiled objects). But when it comes to compiled objects, a library can provide several objects as a <strong>single binary pack</strong> or as a <strong>set of separate binaries</strong> (where each object has its own binary).</p>
<p>The “classic” library format is a single binary pack (with two or more externals), but splitting into separate binaries became a very common practice. A single external binary (not part of any set of objects) is still, technically, a library with just one object. But again, the prevailing idea is that a library is just a set of objects.</p>
<p>It’s important to note that there are differences on how externals are loaded depending if they’re a single binary pack or a set of separate binaries (as explained in the next subsections).</p>
<h3 id="414-what-are-the-types-of-external-libraries">4.1.4. What are the types of External Libraries?</h3>
<p>Libraries can come in all sorts of ways; as only a collection of abstractions (like &quot;list-abs&quot;), only compiled objects, or both. It can even mix compiled externals both as a <strong>set of separate binaries</strong> and a <strong>single binary pack</strong>. Basically, any combination is possible for a set of external.</p>
<p>One example that combines all external options is <em>Cyclone</em> (since version 0.3), which provides most of its objects as a <strong>set of separate binaries</strong>, but also includes a small collection of 12 objects as a <strong>single binary pack</strong> plus a few abstractions.</p>
<h3 id="wrapping-up-part-1">Wrapping up Part 1)</h3>
<ul>
<li><strong>Internal objects:</strong> Objects that are part of Pd Vanilla&apos;s binary.</li>
<li><strong>External objects:</strong> Objects that are NOT part of Pd Vanilla&apos;s binary.</li>
<li><strong>Vanilla objects:</strong> Built-in objects in the Pd Vanilla distribution (including internals and a small collection of externals - the &quot;extra&quot; objects).</li>
<li><strong>Types of external objects:</strong> Compiled binaries or Abstractions.</li>
<li><strong>External Library:</strong> Collection of external objects in any form, be it a single binary pack containing several objects, a set of separate binaries / abstractions or any combination of them.</li>
</ul>
<hr>
<h3 id="42-installing-external-objects-and-libraries">4.2. Installing External Objects and Libraries</h3>
<p>Installing externals in Pd is quite simple, all you need to do is download your externals from somewhere, such as from Pd Vanilla directly, and include them in a proper folder.</p>
<h3 id="421-where-to-include-the-externals">4.2.1. Where to include the externals?</h3>
<p>Currently, when launching for the first time with a fresh install, Pd asks if you want to create a documents directory for patches that includes an “externals” subdirectory. This externals folder is where it’s advised to include external libraries and it’s automatically included in the user added search paths (under Preferences =&gt; Path), see figure below.</p>
<p><img src="fig4.3.png" alt>  </p>
<p>We see in the screenshot above that the “Pd” folder is created under ~/Documents, and inside it we have the externals subfolder. Even if you did not create this folder, here is where you can create it by clicking the “Reset” button under “Pd Documents Directory”.</p>
<p>Externals can actually be anywhere in your computer, but Pd must know where to look for them. Pd looks for files (including externals) in the user added search paths, but it also searches in other folders not listed there such as: the same folder that your patch is saved on (the Relative Path) and the Standard Paths, which are:</p>
<ul>
<li>A) Application-specific: The &quot;extra&quot; folder inside a particular Pure Data application.</li>
<li>B) User-specific: A system folder for a specific user in the machine.</li>
<li>C) Global: A system folder for all users on the machine.</li>
</ul>
<p>Officially, there’s only one ‘Standard Path’ which is the ‘extra’ folder. The others are not automatically created by Pd and are part of an old structure. Currently, the best practice is to use the default external folders or user added paths, but these other options are documented here anyway and may be useful in some edge cases.</p>
<p>The Global folder affects all Pure Data Applications for all users. The User-specific folder affects all Pure Data Applications for that user. And since you can have different versions of Pd installed in your system, the Application-specific folder affects only that particular Pd Application - multiple Pd applications can be of different versions (an older and a newer one or both 32-bit and 64-bit). For reference, here’s the list of the Standard Paths for all operating systems:</p>
<p>A) macOS:</p>
<ul>
<li>Application-specific: <strong>/$PdPath/Contents/Resources/extra</strong> - this is inside the Pd Application (like Pd-0.49-1 in ~/Applications); right click it and choose &quot;Show Package Contents&quot;, then navigate to &quot;Resources/extra&quot;.</li>
<li>User-specific: <strong>~/Library/Pd</strong> (/Users/user_name/Library/Pd)</li>
<li>Global: <strong>/Library/Pd</strong></li>
</ul>
<p>B) Windows:</p>
<ul>
<li>Application-specific: <strong>%ProgramFiles(x86)%\Pd\extra</strong> (for 64-bit OS and 32-bit Pd) or %ProgramFiles%\Pd\extra; this is inside the Pd Application (usually in C:\Program Files). This folder needs to be set to writeable.</li>
<li>User-specific: <strong>%AppData%\Pd</strong> (usually in C:\Users\user_name\AppData\Roaming\Pd).</li>
<li>Global: <strong>%CommonProgramFiles%\Pd</strong> (usually in C:\Program Files\Common Files\Pd).</li>
</ul>
<p>C) GNU/Linux:</p>
<ul>
<li>Application-specific: <strong>/usr/lib/pd/extra</strong> if installed via a package manager (apt-get) or /usr/local/lib/pd/extra if compiled by yourself.</li>
<li>User-specific: <strong>~/.local/lib/pd/extra</strong> (preferred since version Pd-0.47-1) or ~/pd-externals (deprecated but still usable).</li>
<li>Global: <strong>/usr/local/lib/pd-externals</strong>.</li>
</ul>
<h3 id="422-how-to-download-externals-from-pd-vanilla">4.2.2. How to Download Externals from Pd Vanilla?</h3>
<p>Since version 0.47-0, Pd Vanilla has its own external manager! This is a built in .tcl plug-in named &quot;deken&quot; (check <a href="https://github.com/pure-data/deken" target="_blank">https://github.com/pure-data/deken</a> for reference). Open it by selecting the <strong>Help =&gt; Find externals</strong> tab. Then you can type and search for object name, library name or both. The wildcard &apos;*&apos; can be used to broaden the search, or an exact name can be used instead. All available versions of the library/external specific for your operating system will be shown to you. See figure below.</p>
<p><img src="deken.gif" alt>  </p>
<p>When you double-click on the version you want, by default Pd downloads it to &quot;~/Documents/Pd/externals&quot;.  </p>
<hr>
<h3 id="43-loading-externals">4.3. Loading Externals</h3>
<p>The current best practice is to use the declare object to search for, load and manage externals, but there are alternatives.</p>
<p>If the object is from a library that is distributed as a single binary pack, this binary needs to be pre loaded so Pd can create its externals. This is done either with declare or manually via Preferences =&gt; Startup.</p>
<p>If the external library only contains abstractions or objects compiled as a set of separate binaries, Pd just needs to know its path. Again, this can be done with declare or manually via Preferences =&gt; Path, but yet another option here is to use slash declarations as we&apos;ll see later.</p>
<h3 id="431-using-the-declare-object">4.3.1. Using the [declare] object:</h3>
<p>The declare object can be used to add search paths or load libraries. When adding a path, it behaves quite similarly to adding search paths to the user added paths (under Preferences =&gt; Path). The difference is that this will only work for the patch that contains the declare object - unlike using path, which loads permanently for any patch.</p>
<p>As for loading a library, once Pd loads it (via [declare] or startup) it sticks with it. This means that if you use [declare] to load a library, it will also be loaded if you create a new patch without any [declare] object.</p>
<h3 id="4311-declare--path">4.3.1.1. [declare -path]:</h3>
<p>Let&apos;s take for an example the <a href="http://github.com/porres/pd-else" target="_blank">ELSE</a> library. This library contains separate binaries and abstractions, so Pd only needs to know its location path. We then use the &apos;-path&apos; flag as in [declare -path else]. This makes Pd look for a folder named &apos;else&apos; to add it to the search path for that patch only. When and if it succeeds in finding this folder with [declare], this is where Pd will prioritize the search of objects and other files, moving on to other possible search places if nothing is found.</p>
<p>But where does Pd look for the &apos;else&apos; folder? Well, the -path flag is first meant to search in the Relative Path, but if it doesn&apos;t find it, it falls back to the User Added Paths and Standard Paths. So let’s say you put the ELSE library folder in “~/Documents/Pd/externals”, which is the current best practice, Pd will know to look for it there and will find it!</p>
<p>Now, in the case of a single external, the best practice is to include it in a folder with the same name in “~/Documents/Pd/externals”. An example, the freeverb~ external should be in “~/Documents/Pd/externals/freeverb~”. In this situation, you don’t need to add the external folder to the path, manually or use [declare]. This is because when you tell Pd to look for an external, if it finds a folder with the same name as the external, it&apos;ll know to search inside that folder for the external!</p>
<h3 id="4312-declare--lib">4.3.1.2. [declare -lib]:</h3>
<p>The &apos;-lib&apos; flag is needed for the classic Pd library format, which is a single binary pack with many externals. One such example is the <a href="https://git.iem.at/pd/zexy/" target="_blank">zexy</a> library. So you should download and have the &apos;zexy&apos; folderr in “~/Documents/Pd/externals/zexy”. Now you can use [declare -lib zexy] to load the external binary. In the same way as explained with the freeverrb~ example, the binary is inside a folder with the same name. So Pd will search for the external in “~/Documents/Pd/externals&quot;, will find the &apos;zexy&apos; folder and know to search for the zexy binary in it. This means you don&apos;t need to bother in using [declare] to define the search path.</p>
<p>Note that it may be possible for you to load a library binary as an object if the developer wished to. But it&apos;s still advisable to use either &quot;Startup&quot; or [declare -lib], because this way you are sure the library is preloaded before Pd tries to create other objects in your patch.</p>
<p>For more details on how [declare] works, please check its help file!</p>
<h3 id="432-load-via-path-and-startup">4.3.2. Load via Path and Startup:</h3>
<p>We&apos;ll now see the differeces between using [declare] or using &quot;Path&quot; and &quot;Startup&quot;.</p>
<h3 id="4321-user-added-path">4.3.2.1. User added Path:</h3>
<p>One big difference in adding a search path in &quot;Preferences =&gt; Path&quot; &quot;is that this permanently adds the path and work every time Pd starts and for any patch you open. When you use [declare], the path is loaded only for its owning patch and loaded abstractions. Moreover, if you have an abstraction with [declare -path], it&apos;ll only work for that abstraction and not the parent patch. Hence, [declare] allows a much better control and management of paths. But you may want to permanently add a path in your own system if you know exactly what you have and what you need.</p>
<p>We’ve seen that even if you have a folder into “~/Documents/Pd/externals” you still need to tell Pd to look for it. You can manually add a User Added Paths in Preferences =&gt; Path by clicking “New”.</p>
<p>Another possibility is that under deken’s preferences tabs you can click on “Add newly installed libraries to Pd’s search Path”, which adds downloaded libraries to the user added search paths.</p>
<p>Note also that having a user added search path will not make it have search priority like it happens when you use [declare]. In this case, the path relative to the patch will always have top priority!</p>
<h3 id="4322-startup">4.3.2.2. Startup:</h3>
<p>&quot;Preferences =&gt; Startup&quot; loads a window that says <em>&quot;Pd libraries to load on startup&quot;</em>. This is where you can manually and permanently load single binary pack libraries. But since they&apos;re only needed during startup, you need to restart Pd so this takes effect. The startup is also used for configuring Pd in many ways, see <a href="x3.html#s4">3.6. Preferences and startup options</a> for reference.</p>
<p><img src="fig4.5.png" alt>  </p>
<p>As we’ve seen with ‘zexy’, it’s common that the name of the binary is the same as the library’s, so you don’t need to worry about adding it to the path. Another example is the ‘cyclone’ library. As previously mentioned, Cyclone includes objects as abstractions, as a set of separate binaries and also has a set a single binary pack (which loads objects with non alphanumeric names that need to be loaded as such to avoid issues). One particularity of cyclone is that loading its binary will also force Pd to add its path to the search paths, so you don’t need to bother adding it to the path as well in order to be able to load its abstractions or separate binaries. Another example that uses this feature is <a href="https://github.com/umlaeute/Gem" target="_blank">Gem</a> , which loads as a binary pack but also includes a few abstractions that rely on the path search. Note, however, that unlike using [declare], this does not enforce a search priority! Hence, for example, you may prefer to use [declare -path cyclone -lib cyclone] instead.</p>
<p>It all depends on the developer, but it is a common and good practice that when you load a library, Pd’s terminal window will print something to tell us that the libraries were loaded successfully. Here’s a screenshot of the result of loading cyclone and zexy via the startup (same happens if you load them via [declare], clearly).</p>
<p>Note that when you load a library like this or via [declare -lib], all of its external objects are loaded in Pd and they have search priority. This may cause issues discussed on the next section.</p>
<p><img src="fig4.6.png" alt>  </p>
<h3 id="433-slash-declarations">4.3.3. Slash declarations:</h3>
<p>What is this and how does it work? Let’s say you’ve downloaded the ELSE library into ~/Documents/Pd/externals. Instead of using [declare -path else] or adding the ELSE folder to the user added paths manually, you can just prepend “else/“ before an object name. This will make Pd look for this object in a folder called ‘else’ in one of its search paths (which includes ~/Documents/Pd/externals) and find it! Here’s an example:</p>
<p><img src="fig4.7.png" alt></p>
<p>Now, what’s the need or advantage of this over using [declare] or adding the folder to the user added paths? This can be an option that some people may prefer for the simple fact that it&apos;s just clearer from which library folder we&apos;re loading the external. But there are some rare cases where this is the only way to guarantee you have loaded the correct external, which is a problem when you have too many libraries in your system and using more than one that has an external with the same name. Hence, some external libraries like &apos;Cyclone&apos; and &apos;ELSE&apos; use this in the documentation of the help files to make sure you load the correct external.</p>
<p>Note, however, that this is not possible for an external that is loaded as part of a single binary pack, unless the developer uses a workaround to add this possibility as alternative.</p>
<p>The issue with [declare] or adding a path to the user added paths is that it&apos;ll respect a search order. Whatever path is added first in the search list order has a priority, and where ever Pd finds an external first, it&apos;ll load it and stop searching elsewhere. Again, this kind of problem is not that common, but you may be able to sort this issue by setting the desired order. This is quite easy in [declare], which ever -path comes first in the list has a priority. You can try this if you want to avoid slash declarations when you run into this rare issue.</p>
<p>Such conflicts can also happen when you&apos;re loading single binary pack libraries. The problem is that once they get loaded, all of its external objects are now part of Pd and have a priority in the search. Here&apos;s an example, the &apos;ceammc&apos; library is a single binary pack and it included an object called [xfade~]. The ELSE library has separate binaries for each object and also has one called [xfade~]. If you&apos;re using both libraries, ceammc&apos;s [xfade~] object will have priority and it deosn&apos;t help you to have [declare -path else]. You can then use [else/xfade~] to specifically call ELSE&apos;s [xfade~] instead.</p>
<p>It was mentioned how a library name prefix may also be possible in the context of single binary packs. The ceammc library offers this, so you can also load its [xfade~] object as [ceammc/xfade~]. But note that this still requires you to preload the binary (via startup or [declare]). The slash declaration here was only possible because the developer added the &apos;ceammc/xfade~&apos; name as an alternative option in the code. So it is just a hack to improve the limitation of Pd in handling namespaces. Another library that does this is Cyclone, which carries a sublibrary with 12 objects with non alphanumeric names, such as [&gt;~]. By using the same trick, you can create the [&gt;~] object as [cyclone/&gt;~]. Another single binary pack library that has [&gt;~] is zexy, so this way you can make sure you&apos;re getting cyclone&apos;s instead.</p>
<p>These issues might be clear if you better understand how Pd works when loading externals. See next subsection.</p>
<h3 id="44-how-external-binaries-are-loaded">4.4. How external binaries are loaded</h3>
<p>Once you make sure Pd can load an external binary, this is what happens when you create it. Whenever you type the name of an object (into an &quot;object&quot; box) that Pd doesn&apos;t yet know about, Pd looks for the object file named, for instance, as &quot;profile.pd_linux&quot;. Pd looks first in a path defined by [declare] (if any, of course), then in the directory containing the patch, then in directories listed as user added paths in the orderr they are listed, then in the standard paths. As soon as Pd finds the object in this search order, it&apos;ll stop searching further more and will add the found object to its &quot;class list&quot;, which is the set of all Pd classes you can use. Pd then tries to create the object you asked for, and if everrything is fine with it, this happens successfully (creation errors are given otherwise). In the case of a single binary pack, all the externals it contains get preloaded in Pd, even though they&apos;re only created in object boxes when you require them.</p>
<p>Once an external object&apos;s binary is in Pd&apos;s memory, there is no real difference between it and a native object. They&apos;re all seen equally now in Pd. Once a new separate binary or single binary pack is loaded, it&apos;s there for the duration of your Pd session. This means that if you replace the binaries, the objects won&apos;t be updated even if you recreate them. You can also even delete the binary as Pd now carried it for good. Hence, if you&apos;re working on the development of an object&apos;s binary and decide to change it, you have to exit and re-enter Pd to get the change to take.</p>
<p>Let us just make the distinction that external abstractions work quite differently! As they get updated any time they’re updated and reloaded!</p>
<h3 id="441-overriding-objects-externals-and-native">4.4.1. Overriding objects (externals and native):</h3>
<p>We&apos;ve seen that Pd loads and sticks to an external. But this can get overridden. We&apos;ve actually seen that already. For instance, you create [xfade~] from ELSE, then you load ceammc&apos;s binary that also has an [xfade~] object. Now Pd only knows about [xfade~] from ceammc! It&apos;s been also noted how cyclone and zexy have objects with the same name. If you first load cyclone&apos;s binary and zexy&apos;s later, zexy&apos;s objects with the same name (such as [&gt;~]) will override and prevail.</p>
<p>And here&apos;s an interesting feature, you can also override internal Pd Vanilla objects with externals! Say you have an external called [phasor~]. It it&apos;s a single binary, you can force Pd to find it with slash declarations. Otherwise, if it&apos;s a binary pack, you can load as any other library and if it has objects with the same name as vanilla&apos;s internals, they get overridden! But Pd still keeps a copy of the old one and renames it by appending &quot;_aliased&quot;, so you can still load the old &quot;phasor~&quot;, for instance, as <strong>[phasor~_aliased]</strong>. You probably don&apos;t want to mess overriding internals, but it makes sense if you provide new versions with more features but fully backwards compatible.</p>
<h3 id="45-search-order-for-loading-objects">4.5. Search order for loading objects</h3>
<p>This information has been provided in pieces throughout this section of the Manual. But now well wrap it up after all the information has been presented.</p>
<p>So, whenever you tell Pd to create an object in its box, this is what happens.</p>
<p><strong>First</strong> it searches in its object list. This includes all of Pd&apos;s internals and other externals that may have been previously loaded.</p>
<p><strong>Second</strong>, it moves on to possible paths. And if you have [declare -path] in your patch, the defined path(s) has/have priority respecting the order they are listed from left to right.</p>
<p><strong>Third</strong> is time to search the path relative to the patch.</p>
<p><strong>Fourth</strong> it goes to the user added paths, defined at &quot;Preferences =&gt; Path&quot;. An order is also respeccted, from top to bottom.</p>
<p><strong>Fifth</strong> and last, it searches the &quot;standard paths&quot;, which includes the &apos;extra&apos; library provided by the Pd Vanilla distribution. Note you can use [declare -stdpath ./] to force priority to search this folder!</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="PdM_Run.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: 3. Getting Pd to run">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"4. Externals","level":"2.1.4","depth":2,"previous":{"title":"3. Getting Pd to run","level":"2.1.3","depth":2,"path":"PdM_Run.md","ref":"PdM_Run.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"PdM_Externals.md","mtime":"2023-03-06T18:39:27.665Z","type":"markdown"},"gitbook":{"version":"4.0.4","time":"2023-03-07T18:50:57.158Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

